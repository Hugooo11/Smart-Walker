========================================================
RESET LIMPO ‚Äì RASPBERRY PI ZERO 2W
USB ETHERNET + STREAM DE V√çDEO (VERS√ÉO FINAL)
========================================================

OBJETIVO
--------
- Raspberry Pi Zero 2W como SENSOR (c√¢mara CSI)
- Jetson Nano escreve TODO o c√≥digo
- V√≠deo em tempo real na Jetson
- Liga√ß√£o f√≠sica Pi ‚Üî Jetson por cabo USB
- Pi arranca, transmite v√≠deo e n√£o precisa de monitor
- tmux validado ANTES de perder teclado
- NENHUM uso de ttyGS0 / serial

========================================================
FASE 0 ‚Äì REGRAVAR CART√ÉO SD (BASE LIMPA)
========================================================
No Mac / PC (Raspberry Pi Imager):

Device:
- Raspberry Pi Zero 2 W

OS:
- Raspberry Pi OS (Legacy)
- Raspberry Pi OS Lite (32-bit)
  (Bookworm, N√ÉO trixie, N√ÉO 64-bit)

Advanced options:
- Enable SSH: ON
- Username: pi
- Password: definir
- Locale / teclado: confirmar
- Wi-Fi: opcional (n√£o √© obrigat√≥rio para o objetivo final)

‚Üí Write
‚Üí Eject

========================================================
FASE 1 ‚Äì PRIMEIRO ARRANQUE (COM TECLADO)
========================================================
Liga√ß√µes:
- HDMI ‚Üí monitor
- Teclado USB ‚Üí Pi
- Alimenta√ß√£o ‚Üí PWR IN
- N√ÉO ligar Jetson

Confirmar:
- Login funciona
- Teclado responde

Confirmar OS:
cat /etc/os-release
Esperado:
VERSION_CODENAME=bookworm

========================================================
FASE 2 ‚Äì ATUALIZAR SISTEMA
========================================================
sudo apt update && sudo apt full-upgrade -y
sudo reboot

========================================================
FASE 3 ‚Äì C√ÇMARA (OBRIGAT√ìRIO)
========================================================
Instalar:
sudo apt install -y libcamera-apps rpicam-apps python3-picamera2 python3-opencv python3-flask

Testes:
rpicam-hello
rpicam-still -o test.jpg

Teste Python (resolu√ß√£o baixa ‚Äì Zero 2W):
nano test_cam.py

CONTE√öDO:
----------------------------------------
from picamera2 import Picamera2

picam2 = Picamera2()
config = picam2.create_still_configuration(
    main={"size": (640, 480)}
)
picam2.configure(config)
picam2.start()
picam2.capture_file("py_test.jpg")
print("OK")
----------------------------------------

Executar:
python3 test_cam.py

========================================================
FASE 4 ‚Äì STREAM DE V√çDEO (NO PI)
========================================================
Criar diret√≥rio:
mkdir -p ~/camera
cd ~/camera

Criar servidor MJPEG:
nano stream_mjpeg.py

CONTE√öDO:
----------------------------------------
from flask import Flask, Response
import cv2

app = Flask(__name__)
cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
cap.set(cv2.CAP_PROP_FPS, 15)

def gen():
    while True:
        ok, frame = cap.read()
        if not ok:
            continue
        ok, jpg = cv2.imencode(".jpg", frame, [int(cv2.IMWRITE_JPEG_QUALITY), 70])
        if not ok:
            continue
        yield (b"--frame\r\n"
               b"Content-Type: image/jpeg\r\n\r\n" + jpg.tobytes() + b"\r\n")

@app.route("/video")
def video():
    return Response(gen(),
        mimetype="multipart/x-mixed-replace; boundary=frame")

app.run(host="0.0.0.0", port=8080, threaded=True)
----------------------------------------

========================================================
FASE 5 ‚Äì VALIDAR tmux (ANTES DE PERDER TECLADO)
========================================================
Instalar:
sudo apt install -y tmux

Criar sess√£o:
tmux new -s camera

Dentro do tmux:
python3 ~/camera/stream_mjpeg.py

Sair SEM matar:
Ctrl+B depois D

Confirmar:
tmux ls

Voltar:
tmux attach -t camera

üëâ SE ISTO FUNCIONAR:
tmux est√° validado para headless.
=======================================================
========================================================
FASE 5.5 ‚Äì CONFIRMA√á√ÉO EDI√á√ÉO CR√çTICA VIA MAC (ANTES DO OTG)
========================================================

OBJETIVO
--------
- Garantir que QUALQUER edi√ß√£o sens√≠vel √© feita remotamente
- Validar SSH, tmux e controlo sem usar o teclado do Pi
- Usar o Mac como ‚Äúrede de seguran√ßa‚Äù ANTES do ponto sem retorno

--------------------------------------------------------
PR√â-CONDI√á√ïES
--------------------------------------------------------
- Pi ainda com teclado e monitor ligados
- tmux j√° testado e funcional
- Stream a correr dentro do tmux
- Mac ligado √† mesma rede (Wi-Fi ou Ethernet)

--------------------------------------------------------
PASSO 1 ‚Äì CONFIRMAR IP DO PI
--------------------------------------------------------
No Pi:
hostname -I

Guardar o IP (ex: 192.168.x.x)

--------------------------------------------------------
PASSO 2 ‚Äì LIGAR POR SSH A PARTIR DO MAC
--------------------------------------------------------
No Mac (Terminal):

ssh -o ServerAliveInterval=10 -o ServerAliveCountMax=3 pi@IP_DO_PI

Confirmar:
- login funciona
- comandos respondem
- sess√£o √© est√°vel

--------------------------------------------------------
PASSO 3 ‚Äì VALIDAR tmux REMOTAMENTE
--------------------------------------------------------
Ainda no SSH (Mac ‚Üí Pi):

tmux ls
tmux attach -t camera

Confirmar:
- stream continua ativo
- tmux recupera sess√£o corretamente

Sair sem matar:
Ctrl+B depois D

--------------------------------------------------------
PASSO 4 ‚Äì REGRA DE SEGURAN√áA (IMPORTANTE)
--------------------------------------------------------
A partir deste ponto:
- QUALQUER edi√ß√£o de ficheiros cr√≠ticos
  (config.txt, cmdline.txt, servi√ßos)
  ser√° feita **exclusivamente via SSH a partir do Mac**
- O teclado do Pi passa a ser apenas conting√™ncia

üëâ S√≥ avan√ßar para a configura√ß√£o OTG
üëâ depois desta fase estar 100% validada

========================================================

========================================================
FASE 6 ‚Äì CONFIGURAR USB ETHERNET (OTG CORRETO)
========================================================
Editar config.txt:
sudo nano /boot/firmware/config.txt

Adicionar no FIM:
dtoverlay=dwc2

Guardar e sair.

Editar cmdline.txt:
sudo nano /boot/firmware/cmdline.txt

‚ö†Ô∏è UMA √öNICA LINHA

Adicionar (ap√≥s rootwait):
modules-load=dwc2,g_ether

Exemplo:
----------------------------------------
console=serial0,115200 console=tty1 root=PARTUUID=XXXX rootfstype=ext4 fsck.repair=yes rootwait modules-load=dwc2,g_ether
----------------------------------------

Guardar.

REBOOT (√öNICO):
sudo reboot

========================================================
FASE 7 ‚Äì PONTO SEM RETORNO
========================================================
1) Desligar monitor e teclado do Pi
2) Ligar:
   - micro-USB do Pi (porta do teclado)
   - ‚Üí USB-A da Jetson
3) Alimentar o Pi

========================================================
FASE 8 ‚Äì NA JETSON (CONFIRMA√á√ÉO)
========================================================
Na Jetson:

ip a
(deve aparecer usb0 ou enx*)

Ping ao Pi:
ping 192.168.7.2

Teste v√≠deo:
python3

----------------------------------------
import cv2
cap = cv2.VideoCapture("http://192.168.7.2:8080/video")
while True:
    ok, frame = cap.read()
    if not ok:
        break
    cv2.imshow("Pi Camera", frame)
    if cv2.waitKey(1) == 27:
        break
----------------------------------------

========================================================
RESULTADO FINAL
========================================================
- Jetson recebe v√≠deo em tempo real ‚úî
- Pi n√£o precisa de monitor ‚úî
- Pi n√£o precisa de teclado ‚úî
- Liga√ß√£o f√≠sica por cabo USB ‚úî
- C√≥digo todo escrito na Jetson ‚úî
- Arquitetura correta e defens√°vel ‚úî

========================================================
REGRAS DE SEGURAN√áA
========================================================
- NUNCA usar ttyGS0
- USB ‚â† c√¢mara, USB = rede
- V√≠deo √© SEMPRE stream
- Processos cr√≠ticos correm SEMPRE em tmux
- Se OTG falhar ‚Üí regravar SD
========================================================
